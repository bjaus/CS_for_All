##[CS for All](https://www.cs.hmc.edu/csforall/)

##Table of Contents

###Introduction

####Chapter 1: Introduction
1. What is Computer Science?
    1. Data
    2. Algorithms
    3. Programming
    4. Abstraction
    5. Problem Solving and Creativity
2. PicoBot
    1. The Roomba Problem
    2. The Environment
    3. State
    4. Think locally, act globally
    5. Whatever
    6. Algorithms and Rules
    7. The Picobot challenge
    8. A-Maze Your Friends!
    9. Uncomputable environments

###Functional Programming

####Chapter 2 : Functional Programming
2.1 Humans, Chimpanzees, and Spell Checkers
2.2 Getting Started in Python
2.2.1 Naming Things
2.2.2 What’s in a Name?
2.3 More Data: From Numbers to Strings
2.3.1 A Short Note on Length
2.3.2 Indexing
2.3.3 Slicing
2.3.4 String Arithmetic
2.4 Lists
2.4.1 Some Good News!
2.5 Functioning in Python
2.5.1 A Short Comment on Docstrings
2.5.2 An Equally Short Comment on Comments
2.5.3 Functions Can Have More Than One Line
2.5.4 Functions Can Have Multiple Arguments
2.5.5 Why Write Functions?
2.6 Making Decisions
2.6.1 A second example
2.6.2 Indentation
2.6.3 Multiple Conditions
2.7 Recursion!
2.8 Recursion, Revealed
2.8.1 Functions that Call Functions
2.8.2 Recursion, Revealed, Really!
2.9 Building Recursion Muscles
2.10 Use It Or Lose It
2.11 Edit distance!
2.12 Conclusion

####Chapter 3: Functional Programming, Part Deux
3.1 Cryptography and Prime Numbers
3.2 First-Class Functions
3.3 Generating Primes
3.4 Filtering
3.5 Lambda
3.6 Putting Google on the Map!
3.6.1 Map
3.6.2 Reduce
3.6.3 Composition and MapReduce
3.7: Functions as Results
3.7.1: Python Does Calculus!
3.7.2: Higher Derivatives
3.8: RSA Cryptography Revisited
3.9: Conclusion

###Computer Organization

###Chapter 4: Computer Organization
4.1 Introduction to Computer Organization
4.2 Representing Information
4.2.1 Integers
4.2.2 Arithmetic
4.2.3 Letters and Strings
4.2.4 Structured Information
4.3 Logic Circuitry
4.3.1 Boolean Algebra
4.3.2 Making Other Boolean Functions
4.3.3 Logic Using Electrical Circuits
4.3.4 Computing With Logic
4.3.5 Memory
4.4 Building a Complete Computer
4.4.1 The von Neumann Architecture
4.5 Hmmm
4.5.1 A Simple Hmmm Program

##How Does It Work?
Trying It Out
4.5.2 Looping
4.5.3 Functions
4.5.4 Recursion

##Stacks
###Saving Precious Possessions
4.5.5 The Complete Hmmm Instruction Set
4.5.6 A Few Last Words
4.6 Conclusion

##Imperative Programming
##Chapter 5: Imperative Programming
5.1 A Computer that Knows You (Better than You Know Yourself?)
5.1.1 Our Goal: A Music Recommender System
5.2 Getting Input from the User
5.3 Repeated Tasks–Loops
5.3.1 Recursion vs. Iteration at the Low Level
5.3.2 Definite Iteration: for loops
5.3.3 How Is the Control Variable Used?
5.3.4 Accumulating Answers
5.3.5 Indefinite Iteration: while Loops
5.3.6 for Loops vs. while Loops
5.3.7 Creating Infinite Loops On Purpose
5.3.8 Iteration Is Efficient
5.4 References and Mutable vs. Immutable Data
5.4.1 Assignment by Reference
5.4.2 Mutable Data Types Can Be Changed Using Other Names!
5.5 Mutable Data + Iteration: Sorting out Artists
5.5.1 Why Sort? Running Time Matters
5.5.2 A Simple Sorting Algorithm: Selection Sort
5.5.3 Why selectionSort Works
5.5.4 A Swap of a Different Sort
5.5.5 2D Arrays and Nested Loops
5.5.6 Dictionaries
5.6 Reading and Writing Files
5.7 Putting It All Together: Program Design
5.8 Conclusion

##Object-Oriented Programming
###Chapter 6: Fun and Games with OOPs: Object-Oriented Programs
6.1 Introduction
6.2 Thinking Objectively
6.3 The Rational Solution
6.4 Overloading
6.5 Printing an Object
6.6 A Few More Words on the Subject of Objects
6.7 Getting Graphical with OOPs
6.8 Robot and Zombies, Finally!
6.9 Conclusion

###Problem “Hardness”
###Chapter 7: How Hard is the Problem?
7.1 The Never-ending Program
7.2 Three Kinds of Problems: Easy, Hard, and Impossible.
7.2.1 Easy Problems
7.2.2 Hard Problems
7.3 Impossible Problems!
7.3.1 “Small” Infinities

###“Larger” Infinities
7.3.2 Uncomputable Functions
7.4 An Uncomputable Problem
7.4.1 The Halting Problem
7.5 Conclusion
